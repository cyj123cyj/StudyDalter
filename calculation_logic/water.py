# -*- coding: utf-8 -*-
import os
import scipy
import numpy as np
import pydicom as dicom

from pydicom.errors import InvalidDicomError
from scipy import stats
from math import sqrt
from scipy.ndimage.measurements import center_of_mass
from scipy.ndimage import distance_transform_edt, label
from utils.util import canny, avg_CT_number, find_water_edge


DEBUG = False  # True#False
INNER_RADIUS = 95  # 水模体实际半径

if DEBUG:
    import pylab
    from prettytable import PrettyTable


class Water_Phantom:
    def __init__(self, dicom_image_file):
        """
        The dicom image is assumed to image a water phantom
        """
        self.LabelPos = None
        try:
            ds = dicom.read_file(dicom_image_file)  # dicom对象
        except InvalidDicomError:
            print("Please specify a valid DICOM image file!")
            return
        self.dataset = ds
        self.image_array = ds.pixel_array * ds.RescaleSlope + ds.RescaleIntercept  # dicom图像

    def get_ROI_sizes(self, water_reference=False):  # 选取距图像中心10%和40%水模参考值的两个圆形ROI,参考半径选模体半径
        """
        determine the ROI sizes for water CT number, noise, homogeneity
        """
        # get the phantom and water body size
        xc, yc, r_water, r_phantom = self.get_phantom_center()
        # the smaller ROI is 10% of the reference
        r_small = [r_phantom, r_water][water_reference] * .1
        # the larger ROI is 40% of the reference
        r_large = [r_phantom, r_water][water_reference] * .4
        return (r_small, r_large)  # 返回值是小、大两个数字

    def determine_FOV_in_CT_image(self):
        """
        Again this is to detect FOV in a CT image

        in this function, we are not going to generate the FOV in the correct way, which
        may not be followed by the manufacturor of the CT device.

        Instead, we detect the FOV generated by the manufacturor by the fact that
        non-FOV area is normally filled uniformly by a value that is nonsense
        """
        nonsense = self.image_array[0, 0]
        mask = scipy.ones_like(self.image_array)
        mask[scipy.where(self.image_array == nonsense)] = 0  # 选取图像边界
        return mask

    def fill_non_FOV(self):
        """
        this is for the convenience of the edge detection
        pixels outside the FOV are filled with CT values at the boundary of the FOV
        so that the FOV boundary won't be detected as an edge
        """
        mask = self.determine_FOV_in_CT_image()
        emask = scipy.ndimage.morphology.binary_erosion(mask, scipy.ones((3, 3)))
        fill_value = self.image_array[scipy.where(mask - emask)].mean()
        img = self.image_array.copy()
        img[scipy.where(mask == 0)] = fill_value
        return img

    def get_image_edges(self):
        # the thresholds were determined empirically, this is related to the contrast
        #   between water and the container
        if hasattr(self, 'edges'):  # 如果算过了就直接返回
            return self.edges
        canny_edges = canny(self.fill_non_FOV(), sigma=2.0, low_threshold=50, high_threshold=80)
        # canny_edges = canny(self.fill_non_FOV(), sigma = 1.0, low_threshold=20, high_threshold=50)    #用canny算子计算边界
        # remove small regions
        lb, nlb = label(canny_edges, scipy.ones((3, 3)))
        counts, le = scipy.histogram(lb, bins=list(range(1, nlb + 2)))
        selected_lbs = scipy.where(counts > 100)[0] + 1  # 筛选掉太小的
        edges = lb == selected_lbs[0]
        for i in selected_lbs[1:]:
            edges += lb == i

        if DEBUG:
            import pylab
            pylab.imshow(self.image_array)
            # pylab.imshow(canny_edges)
            ys, xs = scipy.where(edges)
            # print xs, ys
            pylab.plot(xs, ys, 'r.')
            pylab.title("Edges")
            pylab.show()
        self.edges = edges

        return edges

    def get_phantom_outer_boundary(self):
        if hasattr(self, "phantom_outer_boundary"):  # 如果算过了，直接返回
            return self.phantom_outer_boundary
        _ = self.get_water_body_boundary()  # 模体边缘可在水模体边缘函数里计算
        if DEBUG:
            pylab.imshow(self.phantom_outer_boundary)
            pylab.title("Phantom outer boundary")
            pylab.show()
        return self.phantom_outer_boundary

    def get_water_body_boundary(self):
        """
        This is a revision of the previous algorithm
        This is because for Siements CT images including two characters "A" and "R"
        for anterior and right, respectively
        the char "A" is often labeled as the first region, which was determined as
        the "outer boundary" in the previous algorithm
        now change it to the region that has longest radius
        correspondently, the water body is the one with shortest radius
        """
        if hasattr(self, "water_body_boundary"):  # 如果算过了则直接返回
            return self.water_body_boundary
        edges = self.get_image_edges()  # 利用边缘检测canny算子检测出图像中的边界

        centers = [[], []]
        rads = []
        # check each circle's radius
        lb, nlb = label(edges, scipy.ones((3, 3)))
        for i in range(1, nlb + 1):
            ys, xs = scipy.where(lb == i)
            centery, centerx = ys.sum() / len(ys), xs.sum() / len(xs)  # 计算每个连通域的中心
            dists = scipy.hypot(ys - centery, xs - centerx)  # dist是每个点到中心的距离
            radius = dists.mean() * self.dataset.PixelSpacing[0]  # radius是计算出的实际长度
            centers[0].append(centery)
            centers[1].append(centerx)
            rads.append(radius)
        # 20200509,取ind找边缘
        rads = np.array(rads)
        ind = np.where(abs(rads - INNER_RADIUS) < 1)  # 筛选出计算出的半径与实际水模体半径相仿的，即为水模体边界
        ##        print rads,ind
        self.water_body_boundary = lb == (ind[0] + 1)  # scipy.argmin(rads)
        self.phantom_outer_boundary = lb == (scipy.argmax(rads) + 1)  # 半径最大的是模体外边界

        if DEBUG:
            import pylab
            # pylab.imshow(self.water_body_boundary)
            pylab.imshow(self.phantom_outer_boundary)
            pylab.show()

        return self.water_body_boundary

    def get_phantom_center(self):  # 计算出模体的中心以及水和模体的半径
        if hasattr(self, 'centerx'):  # hasattr 函数用于判断对象是否包含对应的属性。倘若已经有了这些，直接返回；没有的话，进行计算
            return [self.centerx,
                    self.centery,
                    self.water_radius,
                    self.phan_radius]
        # get the phantom boundary and the water body boundary
        outer = self.get_phantom_outer_boundary()  # 确定模体在图像中的外边界
        inner = self.get_water_body_boundary()  # 确定水模体在图像中的边界
        # inner

        oys, oxs = scipy.where(outer)
        iys, ixs = scipy.where(inner)
        self.LabelPos = [ixs, iys]

        # the center is defined as the average of the two edges  中心被定义为两条边界的平均值
        yc = (oys.mean() + iys.mean()) / 2.
        xc = (oxs.mean() + ixs.mean()) / 2.

        # the radii                  #此处用来计算水模体和模体的半径
        #   the water body
        r_water = scipy.hypot(iys - yc, ixs - xc).mean()  # hypot函数是计算三角形斜边长的函数
        #   the phantom
        r_phantom = scipy.hypot(oys - yc, oxs - xc).mean()

        [self.centerx,
         self.centery,
         self.water_radius,
         self.phan_radius] = xc, yc, r_water, r_phantom
        print(xc, yc, r_water, r_phantom)
        return xc, yc, r_water, r_phantom

    def get_CT_number_air(self):
        """
        There is not an explicit description that how the CT number of air should be measured
        in the national standard WS 519-2016
        all pixels outside the phantom but 3 pixels a way from the boundary of the field of view
        are used to calculate the average CT number of air
        """

        if hasattr(self, "CT_number_air"):  # 计算过了的话就直接返回
            return self.CT_number_air
        FOV = self.determine_FOV_in_CT_image()  # 得到一张圆形的掩膜
        lb, nlb = label(self.get_phantom_outer_boundary() == 0)
        outer = lb == 1
        air_region = scipy.int8(outer) * FOV
        air_pixel_inds = scipy.where(air_region)
        air_pixels = self.image_array[air_pixel_inds]
        # add by Yahui Peng on 12/2/2019, to compensate the pixels at the edge of the phantom
        # otherwise the estimation of the air CT number may be deviated from -1000 too much.
        print(air_pixels)
        air_pixels = air_pixels[scipy.where(air_pixels < -950)]

        if DEBUG:
            print("percentile (10, 90, 0.1):", scipy.percentile(air_pixels, [10, 90, 0.1]))
            print("current mean = ", air_pixels.mean())
            pylab.imshow(FOV)
            pylab.show()
            pylab.imshow(outer)
            pylab.show()
            pylab.imshow(air_region)
            pylab.title("Air region")
            pylab.show()
            _ = pylab.hist(air_pixels, log=True)
            pylab.show()
        self.CT_number_air = stats.mode(air_pixels)[0][0]
        print(self.CT_number_air)
        # print " mean after corrrection = ", air_pixels.mean()
        if abs(self.CT_number_air + 1000) > 20:
            print("There may be something wrong when the CT number of air is determined!")
            print("   This message is thrown at 'water.py' file line 203.")

        return self.CT_number_air

    def water_roi(self, water_reference=False):
        '''
        to calculate the ct value of water,noise and homogeneity   计算水的CT值、噪声和均匀性
        '''
        # get rid of these because the water_reference parameter may change
        # if calculated
        ##        if hasattr(self, "CT_number_water"):
        ##            return self.CT_number_water, self.noise_water_HU

        pixel_size = self.dataset.PixelSpacing[0]
        img = self.image_array
        xc, yc, water_r, phan_r = self.get_phantom_center()  # 计算出模体的中心以及水和模体的半径
        if DEBUG:
            print("The detected phantom center:")
            print(xc, yc)
            print("the water phantom radius:")
            print(water_r)
            print("the phantom outer radius:")
            print(phan_r)

        r_roi1, r_roi2 = self.get_ROI_sizes(water_reference)  # 选取距图像中心10%和40%模体参考值的两个圆形ROI

        h, w = img.shape
        ##        ym, xm = scipy.mgrid[0:h, 0:w]
        ##        d2 = scipy.power(ym-yc,2) + scipy.power(xm-xc, 2)
        ##        inds = scipy.where(d2 <= math.pow(r_roi1,2))
        ##        inds2 = scipy.where(d2 <= math.pow(r_roi2,2))
        mask = scipy.ones_like(img)  # ones_like函数用来制作一个用1填充的与img一样的图像
        # mask[int(h/2),int(w/2)] = 1
        mask[int(round(yc)), int(round(xc))] = 0  # 模体中心置0
        dmap = distance_transform_edt(mask)
        inds = scipy.where(dmap <= r_roi1)  # 选取10%ROI区域
        inds2 = scipy.where(dmap <= r_roi2)  # 选取40%ROI区域

        if DEBUG:
            timg = img.copy()
            timg[scipy.where(dmap <= r_roi1)] = img.min()
            pylab.imshow(timg, cmap=pylab.cm.gray, interpolation="nearest")
            pylab.show()
            timg[scipy.where(dmap <= r_roi2)] = img.min()
            pylab.imshow(timg, cmap=pylab.cm.gray, interpolation="nearest")
            pylab.show()

        # calculate the average water CT value
        mean_CT_number = scipy.mean(img[inds])  # 计算10%ROI区域CT值均值
        # calculate the standard deviation of water CT values
        std_water_HU = scipy.std(img[inds2])  # 计算40%ROI区域标准差

        av = mean_CT_number
        sd = std_water_HU

        air_CT_number = self.get_CT_number_air()

        noise = sd / (av - air_CT_number)  # 计算噪声，公式：噪声=标准差/（水CT值-空气CT值）
        # correct for the CT slice thickness
        noise *= sqrt(self.dataset.SliceThickness / 10)  # SliceThickness是分辨率

        if DEBUG:
            print("mean water CT number = %f" % mean_CT_number)
            print("# of pixels = %d" % len(inds[0]))
            print("std water CT numer = %f (%f %%)" % (std_water_HU, noise * 100))
            print("# of pixels = %d" % len(inds2[0]))
            print("CT slice thickness = %d mm" % self.dataset.SliceThickness)
            print("CT number of air = %f" % air_CT_number)

        self.CT_number_water = mean_CT_number
        self.std_water_HU = std_water_HU
        self.noise_water_HU = noise

        return mean_CT_number, noise

    def water_roi_new(self):

        pixel_size = self.dataset.PixelSpacing[0]
        img = self.image_array
        xc, yc, water_xs, water_ys, waterx1, waterx2, watery1, watery2 = find_water_edge(img,
                                                                                         pixel_size)  # returnWaterEdge = True
        # 取到模体内部，各边距离2mm
        x1 = int(waterx1 - 2 / pixel_size)  #
        x2 = int(waterx2 + 2 / pixel_size)
        y1 = int(watery1 - 2 / pixel_size)  #
        y2 = int(watery2 + 2 / pixel_size)
        width = int(x1 - x2)
        height = int(y1 - y2)
        waterArea = img[y2:y1, x2:x1]
        xc, yc = xc - x2, yc - y2  # 相对waterArea的中心坐标
        self.LabelPos = [water_xs, water_ys]
        if DEBUG:
            import pylab
            pylab.imshow(waterArea)
            pylab.show()

        ##        mask = scipy.ones_like(waterArea)                                                   #ones_like函数用来制作一个用1填充的与img一样的图像
        ##        #mask[int(h/2),int(w/2)] = 1
        ##
        ##        mask[int(round((watery2+watery1)/2-watery2)), int(round((x2+x1)/2)-x2)]= 0                                       #模体中心置0
        ##        dmap = distance_transform_edt(mask)
        ##        r_roi = (watery1-watery2)/2
        ##        r_roi1 = r_roi*0.1
        ##        r_roi2 = r_roi*0.4
        ##        inds = scipy.where(dmap <= r_roi1)                                            #选取10%ROI区域
        ##        inds2= scipy.where(dmap <= r_roi2)                                            #选取40%ROI区域
        roi1 = waterArea[:, int(xc - width * 0.05):int(xc + width * 0.05)]  # 对应为10%
        roi2 = waterArea[:, int(xc - width * 0.2):int(xc + width * 0.2)]  # 对应40%
        # calculate the average water CT value   
        mean_CT_number = scipy.mean(roi1)
        # calculate the standard deviation of water CT values
        std_water_HU = scipy.std(roi2)
        av = mean_CT_number
        sd = std_water_HU

        air_pixels = scipy.zeros((watery1 - watery2, waterx2 + img.shape[1] - waterx1))

        air_pixels[:, :waterx2] = img[watery2:watery1, :waterx2]
        air_pixels[:, waterx2:] = img[watery2:watery1, waterx1:]
        air_pixels = air_pixels[scipy.where(air_pixels < -950)]
        self.CT_number_air = stats.mode(air_pixels)[0][0]  # 众数
        air_CT_number = self.CT_number_air

        noise = sd / (av - air_CT_number)  # 计算噪声，公式：噪声=标准差/（水CT值-空气CT值）
        # correct for the CT slice thickness
        noise *= sqrt(self.dataset.SliceThickness / 10)  # SliceThickness是分辨率

        # homogeneity
        ##        xc = int(round((x2+x1)/2))
        ##        yc = int(round((watery2+watery1)/2))
        ##        r_from_ctr = r_roi - (10./pixel_size)
        ##        r_from_ctr -= r_roi1
        r_from_ctr = int(width / 2 - 10. / pixel_size - width * 0.05)
        locs = [(xc + r_from_ctr, yc),
                (xc - r_from_ctr, yc),
                ]
        ##        locs = self.get_peripheral_locations(water_reference, from_edge)        #在中心ROI的上、下、左、右方各选取一个和中心ROI同样大小的ROI，确定它们的位置。
        diffs = []
        for x, y in locs:
            roiho = waterArea[:, int(x - width * 0.05):int(x + width * 0.05)]
            avg = scipy.mean(roiho)
            std = scipy.std(roiho)
            # 均值，方差
            diffs.append(abs(avg - av))
        homogeneity = max(diffs)

        if DEBUG:
            print("mean water CT number = %f" % mean_CT_number)
            ##            print("# of pixels = %d"%len(inds[0]))
            print("std water CT numer = %f (%f %%)" % (std_water_HU, noise * 100))
            ##            print("# of pixels = %d"%len(inds2[0]))
            print("CT slice thickness = %d mm" % self.dataset.SliceThickness)
            print("CT number of air = %f" % air_CT_number)
            print("CT homogeneity = %f" % homogeneity)

        self.CT_number_water = mean_CT_number
        self.std_water_HU = std_water_HU
        self.noise_water_HU = noise

        return mean_CT_number, noise, homogeneity

    def calculate_lcd_new(self, box_size):

        # lcd
        pixel_size = self.dataset.PixelSpacing[0]
        img = self.image_array
        xc, yc, water_xs, water_ys, waterx1, waterx2, watery1, watery2 = find_water_edge(img, pixel_size)
        # 取到模体内部，各边距离2mm
        x1 = int(waterx1 - 2 / pixel_size)  #
        x2 = int(waterx2 + 2 / pixel_size)
        y1 = int(watery1 - 2 / pixel_size)  #
        y2 = int(watery2 + 2 / pixel_size)
        width = int(x1 - x2)
        height = int(y1 - y2)

        ##        r = min(int((waterx1-waterx2)/2),int((watery1-watery2)/2))
        buffer_size = 20  # length that off the boundary,20
        ##        n = int((r-buffer_size)*sqrt(2)/2/box_size)*2                              #n是小格子数量
        nx = int((width / 2 - buffer_size) * sqrt(2) / 2 / box_size) * 2
        ny = int((height / 2) * sqrt(2) / 2 / box_size) * 2

        ##        print(n,nx,ny)

        # generate the indices of the boxes
        ys, xs = scipy.mgrid[-ny / 2:ny / 2, -nx / 2:nx / 2] * box_size
        ys += int(round(yc))
        xs += int(round(xc))
        ##        print (xs,ys,xs.ravel(), ys.ravel())
        if DEBUG:
            import pylab
            pylab.imshow(img, cmap="gray")
            pylab.plot(xs, ys, 'r')
            pylab.show()
        ##        xs, ys = self.grid_generation(box_size)                          #得到不同box_size构成的格子区域
        # get ROIs
        ROIs = []
        for x, y in zip(xs.ravel(), ys.ravel()):
            roi = img[int(y):int(y + box_size), int(x):int(x + box_size)]
            ROIs.append(roi)
        ##        print(r,roi)
        ses = [e.std() for e in ROIs]  # 小格子们的标准差
        means = [e.mean() for e in ROIs]  # 小格子们的均值

        lcd = scipy.std(means) * 3.29
        return lcd

    def get_peripheral_locations(self, water_reference, from_edge):
        # peripheral是外围设备的意思。功能：在中心ROI的上、下、左、右方各选取一个和中心ROI同样大小的ROI，确定它们的位置。
        """
        determine the four ROIs for homogeneity at the peripheral zone
        locations are returned anticolockwise from degree of 0 (on the positve x axis)
        确定周边区域均匀性的四个ROI
        位置从0度反时针返回（在正x轴上）
        """
        xc, yc, r_water, r_phantom = self.get_phantom_center()
        ROI_r, _ = self.get_ROI_sizes(water_reference)

        r_from_ctr = r_water - (10. / self.dataset.PixelSpacing[0])
        if from_edge:  # 默认是进行这一步
            r_from_ctr -= ROI_r

        locs = [(xc + r_from_ctr, yc),
                (xc, yc + r_from_ctr),
                (xc - r_from_ctr, yc),
                (xc, yc - r_from_ctr),
                ]
        return locs

    def homogeneity(self, water_reference=False, from_edge=True):
        """
        test the homogeneity of the water phantom
        """
        img = self.image_array
        xc, yc, r_water, r_phantom = self.get_phantom_center()
        center_water, _ = self.water_roi(water_reference)  # 水CT值和噪声

        # determine the diameter of the ROIs on the peripheral   确定外围设备上ROI的直径
        ROI_r, _ = self.get_ROI_sizes(water_reference)
        locs = self.get_peripheral_locations(water_reference, from_edge)  # 在中心ROI的上、下、左、右方各选取一个和中心ROI同样大小的ROI，确定它们的位置。

        diffs = []
        for x, y in locs:
            avg, std = avg_CT_number(img, (x, y), ROI_r)  # 均值，方差
            diffs.append(abs(avg - center_water))

        if DEBUG:
            import pylab
            print(diffs)
            timg = img.copy()
            h, w = timg.shape
            for x, y in locs:
                yg, xg = scipy.mgrid[:h, :w]
                mask = scipy.hypot(yg - y, xg - x) < ROI_r
                timg[scipy.where(mask)] = img.min()
            pylab.imshow(timg, cmap=pylab.cm.gray, interpolation='nearest')
            pylab.show()
        return max(diffs)

    def grid_generation(self, box_size):
        """
        generate multiple ROIs inside the uniform area inside the water phantom     将水模体图像中心上分为n*n的小格子，确定格子的位置
        """
        # get the center
        xc, yc, r, phan_r = self.get_phantom_center()

        # determine the number of grids
        # the number of grid on one direction
        buffer_size = 20  # length that off the boundary
        n = int((r - buffer_size) * sqrt(2) / 2 / box_size) * 2  # n是小格子数量

        # generate the indices of the boxes
        ys, xs = scipy.mgrid[-n / 2:n / 2, -n / 2:n / 2] * box_size
        ys += int(round(yc))
        xs += int(round(xc))
        if DEBUG:
            pylab.imshow(self.image_array, cmap=pylab.cm.gray, interpolation='nearest')
            for y in ys:
                pylab.plot(xs[0], y, 'r-', linewidth=1)
            for i in range(xs.shape[1]):
                pylab.plot(xs[:, i], ys[:, i], 'g-', linewidth=.5)
            pylab.plot(xc, yc, 'o')
            pylab.show()

        return xs, ys

    def calculate_lcd(self, box_size, show_hist=False):  # 以每个格子为ROI分别计算平均CT值和这些值的标准差，根据统计学方法，可以将标准差乘以3.29来衡量低对比可探测能力
        xs, ys = self.grid_generation(box_size)  # 得到不同box_size构成的格子区域
        # get ROIs
        ROIs = []
        img = self.image_array
        for x, y in zip(xs.ravel(), ys.ravel()):
            roi = img[int(y):int(y + box_size), int(x):int(x + box_size)]
            ROIs.append(roi)

        ses = [e.std() for e in ROIs]  # 小格子们的标准差
        means = [e.mean() for e in ROIs]  # 小格子们的均值
        if DEBUG:
            # print scipy.mean(ses)
            # print means
            print("roi size = %s or %s (mm)" % (box_size, box_size * self.dataset.PixelSpacing[0]))
            print("contrast @95CL = %s" % (scipy.std(means) * 3.29), "n=%d" % len(means))
            print("mean = %s; std = %s; " % (scipy.mean(means), scipy.std(means)))

            _ = pylab.hist(means, bins=50)
            pylab.show()
            # a tabulate output
            heading = ["ROI size", "Instance", "Mean", "SE Mean", "STD", "SE STD", "Contrast"]
            tb = PrettyTable(heading)
            row = [box_size,
                   self.dataset.InstanceNumber,
                   "%6.3f" % scipy.mean(means),
                   "%6.3f" % scipy.std(means),
                   "%6.3f" % scipy.mean(ses),
                   "%6.3f" % scipy.std(ses),
                   "%6.3f" % (scipy.std(means) * 3.29)]
            tb.add_row(row)
            print(tb)

        a = scipy.std(means) * 3.29
        return a


class DICOM:
    def __init__(self, pn, seq, im, studyID):
        self.pn = pn
        self.seq = seq
        self.im = im
        self.studyID = studyID

    def Read(self, displayImage=False):
        dcm_dir = dicom.read_dicomdir(os.path.join(self.pn, "DICOMDIR"))
        seqs = dcm_dir.DirectoryRecordSequence
        for seqInd in range(len(seqs)):
            if seqs[seqInd].DirectoryRecordType == 'STUDY' and int(seqs[seqInd].StudyID) == self.studyID:
                for i in range(seqInd, len(seqs)):
                    if seqs[i].DirectoryRecordType == 'SERIES' and int(seqs[i].SeriesNumber) == self.seq:
                        # print 'Found the Series'
                        for j in range(i, len(seqs)):
                            # print 'Examing#%d '%j, seqs[j].DirectoryRecordType
                            if seqs[j].DirectoryRecordType == 'IMAGE' and int(seqs[j].InstanceNumber) == self.im:
                                print(('Found the Image, Seq #%d' % j))
                                fname = os.path.join(self.pn, os.path.join(*seqs[j].ReferencedFileID))
                                return fname


if __name__ == '__main__':
    # pn = 'D:\\Research\\INET\\Du_Guosheng\\data\\validation_dataset\\hepingli_hospital\\4-19\\4-19\\BSoft'
    # pn = '..\\BSoft'
    # pn = "D:\pythonct\py_codenew\new\py_code_latest\py_code_190214_from_Wu\py_code514\old_fromnew\change2\Z"#'..\\A\\Z02'
    seq = 7
    im = 1
    studyID = 1

    # displayImage = True
    # dicomIns = DICOM(pn, seq, im, studyID)
    # fname = dicomIns.Read(True)
    # fname = "F:\\CT_phantom_pictures\\Z313"
    fname = "D:/医学模体图像/冠状和矢状-1\Z01"
    # fname = "C:\\Users\\yanhui\\Desktop\\选取3_1.2.840.113619.2.479.3.2831172866.333.1615105440.971.3_1_512_512.dcm"

    ds = dicom.read_file(fname)

    if 1:  # for f in os.listdir(pn):
        print(fname)
        # fname = os.path.join(pn, f)
        test = Water_Phantom(fname)
        # av, noise = test.water_roi()
        # homogeneity = test.homogeneity()
        # sz1 = 2
        # sz = int(round(sz1 / ds.PixelSpacing[0]))
        # a2 = test.calculate_lcd(sz)
        # # sz1 = 3
        # # sz = int(round(sz1 / ds.PixelSpacing[0]))
        # # a3 = test.calculate_lcd(sz)
        # # sz1 = 5
        # # sz = int(round(sz1 / ds.PixelSpacing[0]))
        # # a5 = test.calculate_lcd(sz)
        # # sz1 = 7
        # # sz = int(round(sz1 / ds.PixelSpacing[0]))
        # # a7 = test.calculate_lcd(sz)
        # lcd = a2
        av, noise, homogeneity = test.water_roi_new()
        ##        homogeneity = test.homogeneity()
        sz1 = 3  # mm                                                                       #这是个什么参数呢？
        sz = int(round(sz1 / ds.PixelSpacing[0]))
        lcd = test.calculate_lcd_new(sz)  # 计算lcd值
        print(("the CT value of water phantom  is : ", av), end=' ')
        print(("the noise of water phantom is : %s %%" % (noise * 100)), end=' ')
        print(("the homogeneity of water phantom is :", homogeneity), end=' ')
        print(("the lcd is:", lcd))
