# -*- coding: utf-8 -*-
import os
import math
import pydicom as dicom
from pydicom.errors import InvalidDicomError

import scipy
from scipy.ndimage.measurements import center_of_mass
from scipy.ndimage import distance_transform_edt, label
from util import canny, avg_CT_number
import numpy as np

from math import sqrt

DEBUG = False
if DEBUG:
    import pylab
#    from prettytable import PrettyTable
INNER_RADIUS = 80
class Water_Phantom:
    def __init__(self, dicom_image_file):
        """
        The dicom image is assumed to image a water phantom
        """
        try:
            ds = dicom.read_file(dicom_image_file)
        except InvalidDicomError:
            print "Please specify a valid DICOM image file!"
            return
        self.dataset = ds
        self.image_array = ds.pixel_array*ds.RescaleSlope+ds.RescaleIntercept

    def get_ROI_sizes(self, water_reference=False):
        """
        determine the ROI sizes for water CT number, noise, homogeneity
        """
        # get the phantom and water body size
        xc, yc, r_water, r_phantom = self.get_phantom_center()
        # the smaller ROI is 10% of the reference
        r_small = [r_phantom, r_water][water_reference] * .1
        # the larger ROI is 40% of the reference
        r_large = [r_phantom, r_water][water_reference] * .4
        return (r_small, r_large)
        
    def determine_FOV_in_CT_image(self):
        """
        Again this is to detect FOV in a CT image

        in this function, we are not going to generate the FOV in the correct way, which
        may not be followed by the manufacturor of the CT device.

        Instead, we detect the FOV generated by the manufacturor by the fact that
        non-FOV area is normally filled uniformly by a value that is nonsense
        """
        nonsense = self.image_array[0,0]
        mask = scipy.ones_like(self.image_array)
        mask[scipy.where(self.image_array == nonsense)] = 0
        return mask

    def fill_non_FOV(self):
        """
        this is for the convenience of the edge detection
        pixels outside the FOV are filled with CT values at the boundary of the FOV
        so that the FOV boundary won't be detected as an edge
        """
        mask = self.determine_FOV_in_CT_image()
        emask = scipy.ndimage.morphology.binary_erosion(mask, scipy.ones((3,3)))
        fill_value = self.image_array[scipy.where(mask - emask)].mean()
        img = self.image_array.copy()
        img[scipy.where(mask == 0)] = fill_value
        return img
        
    def get_image_edges(self):
        # the thresholds were determined empirically, this is related to the contrast
        #   between water and the container
        if hasattr(self, 'edges'):
            return self.edges
        canny_edges  = canny(self.fill_non_FOV(), sigma=2.0, low_threshold=50, high_threshold=80)
        #canny_edges = canny(self.fill_non_FOV(), sigma = 1.0, low_threshold=20, high_threshold=50)

        # remove small regions
        lb, nlb = label(canny_edges, scipy.ones((3,3)))
        counts, le = scipy.histogram(lb, bins=range(1, nlb+2))
        selected_lbs = scipy.where(counts > 100)[0] + 1
        edges = lb == selected_lbs[0]
        for i in selected_lbs[1:]:
            edges += lb == i
        
        if DEBUG:
            pylab.imshow(self.image_array)
            #pylab.imshow(canny_edges)
            ys, xs = scipy.where(edges)
            #print xs, ys
            pylab.plot(xs, ys, 'r.')
            pylab.title("Edges")
            pylab.show()
        self.edges = edges
        return edges

    def get_phantom_outer_boundary(self):
        if hasattr(self, "phantom_outer_boundary"):
            return self.phantom_outer_boundary
        _= self.get_water_body_boundary()
        if DEBUG:
            pylab.imshow(self.phantom_outer_boundary)
            pylab.title("Phantom outer boundary")
            pylab.show()
        return self.phantom_outer_boundary
		
    def get_water_body_boundary(self):
        """
        This is a revision of the previous algorithm
        This is because for Siements CT images including two characters "A" and "R"
        for anterior and right, respectively
        the char "A" is often labeled as the first region, which was determined as
        the "outer boundary" in the previous algorithm
        now change it to the region that has longest radius
        correspondently, the water body is the one with shortest radius
        """
        if hasattr(self, "water_body_boundary"):
            return self.water_body_boundary
        edges = self.get_image_edges()

        centers = [[],[]]
        rads = []
        # check each circle's radius
        lb, nlb = label(edges, scipy.ones((3,3)))
        for i in range(1, nlb+1):
            ys, xs = scipy.where(lb == i)
            centery, centerx = ys.sum()/len(ys), xs.sum()/len(xs)
            dists = scipy.hypot(ys - centery, xs - centerx)
            radius = dists.mean()*self.dataset.PixelSpacing[0]
            centers[0].append(centery)
            centers[1].append(centerx)
            rads.append(radius)
        #20200509,取ind找边缘
        rads = np.array(rads)
        ind = np.where(abs(rads-INNER_RADIUS)<1)
##        print rads,ind
        self.water_body_boundary = lb == (ind[0]+1)#scipy.argmin(rads)
        self.phantom_outer_boundary = lb == (scipy.argmax(rads)+1)
        if DEBUG:
            pylab.imshow(self.water_body_boundary)
            pylab.imshow(self.phantom_outer_boundary)
            pylab.show()
        
        return self.water_body_boundary
        
    def get_phantom_center(self):
        if hasattr(self, 'centerx'):
            return [self.centerx,
                    self.centery,
                    self.water_radius,
                    self.phan_radius]
            
        # get the phantom boundary and the water body boundary
        outer = self.get_phantom_outer_boundary()
        inner = self.get_water_body_boundary()
        oys, oxs = scipy.where(outer)
        iys, ixs = scipy.where(inner)

        # the center is defined as the average of the two edges
        yc = (oys.mean() + iys.mean())/2.
        xc = (oxs.mean() + ixs.mean())/2.

        # the radii
        #   the water body
        r_water = scipy.hypot(iys-yc, ixs-xc).mean()
        #   the phantom
        r_phantom = scipy.hypot(oys-yc, oxs-xc).mean()

        [self.centerx,
         self.centery,
         self.water_radius,
         self.phan_radius] = xc, yc, r_water, r_phantom
        print xc, yc, r_water, r_phantom
        return xc, yc, r_water, r_phantom
        
        
    def get_CT_number_air(self):
        """
        There is not an explicit description that how the CT number of air should be measured
        in the national standard WS 519-2016
        all pixels outside the phantom but 3 pixels a way from the boundary of the field of view
        are used to calculate the average CT number of air
        """
        if hasattr(self, "CT_number_air"):
            return self.CT_number_air
        FOV = self.determine_FOV_in_CT_image()
        lb, nlb = label(self.get_phantom_outer_boundary() == 0)
        outer = lb == 1
        air_region =  scipy.int8(outer) * FOV
        air_pixel_inds = scipy.where(air_region)
        air_pixels = self.image_array[air_pixel_inds]
        # add by Yahui Peng on 12/2/2019, to compensate the pixels at the edge of the phantom
        # otherwise the estimation of the air CT number may be deviated from -1000 too much.
        air_pixels = air_pixels[scipy.where(air_pixels < scipy.percentile(air_pixels, 95))]
        if DEBUG:
            print "percentile (10, 90, 0.1):", scipy.percentile(air_pixels, [10,90,0.1])
            print "current mean = ",air_pixels.mean()
##            pylab.imshow(FOV)
##            pylab.show()
##            pylab.imshow(outer)
##            pylab.show()
            pylab.imshow(air_region)
            pylab.title("Air region")
            pylab.show()
            _=pylab.hist(air_pixels, log=True)
            pylab.show()
        self.CT_number_air = air_pixels.mean()
        #print " mean after corrrection = ", air_pixels.mean()
        if abs(self.CT_number_air + 1000) > 20:
            print "There may be something wrong when the CT number of air is determined!"
            print "   This message is thrown at 'water.py' file line 203."
        return self.CT_number_air
        
    def water_roi(self, water_reference=False):
        '''
        to calculate the ct value of water,noise and homogeneity
        '''
        # get rid of these because the water_reference parameter may change
        #if calculated
##        if hasattr(self, "CT_number_water"):
##            return self.CT_number_water, self.noise_water_HU
            
        pixel_size = self.dataset.PixelSpacing[0]
        img = self.image_array
        xc,yc,water_r,phan_r = self.get_phantom_center()
        if DEBUG:
            print "The detected phantom center:"
            print xc, yc
            print "the water phantom radius:"
            print water_r
            print "the phantom outer radius:"
            print phan_r
        
        r_roi1, r_roi2 = self.get_ROI_sizes(water_reference)
            
        s = []
        #x = int(x)
        #y = int(y)
        #r_roi1 = int(r_roi1)
        #r_roi2 = int(r_roi2)

        h, w = img.shape
##        ym, xm = scipy.mgrid[0:h, 0:w]
##        d2 = scipy.power(ym-yc,2) + scipy.power(xm-xc, 2)
##        inds = scipy.where(d2 <= math.pow(r_roi1,2))
##        inds2 = scipy.where(d2 <= math.pow(r_roi2,2))
        mask = scipy.ones_like(img)
        mask[h/2, w/2] = 1
        mask[int(round(yc)), int(round(xc))]= 0
        dmap = distance_transform_edt(mask)
        inds = scipy.where(dmap <= r_roi1)
        inds2= scipy.where(dmap <= r_roi2)

        if DEBUG:
            timg = img.copy()
            timg[scipy.where(dmap <= r_roi1)] = img.min()
            pylab.imshow(timg, cmap=pylab.cm.gray, interpolation="nearest")
            pylab.show()
            timg[scipy.where(dmap <= r_roi2)] = img.min()
            pylab.imshow(timg, cmap=pylab.cm.gray, interpolation="nearest")
            pylab.show()

        # calculate the average water CT value
        mean_CT_number = scipy.mean(img[inds])
        # calculate the standard deviation of water CT values
        std_water_HU = scipy.std(img[inds2])

        av = mean_CT_number
        sd = std_water_HU

        air_CT_number = self.get_CT_number_air()
        
        noise = sd/(av-air_CT_number)
        # correct for the CT slice thickness
        noise *= sqrt(self.dataset.SliceThickness/10)

        if DEBUG:
            print "mean water CT number = %f"%mean_CT_number
            print "# of pixels = %d"%len(inds[0])
            print "std water CT numer = %f (%f %%)"%(std_water_HU, noise*100)
            print "# of pixels = %d"%len(inds2[0])
            print "CT slice thickness = %d mm"%self.dataset.SliceThickness
            print "CT number of air = %f"%air_CT_number

        
        self.CT_number_water = mean_CT_number
        self.std_water_HU = std_water_HU
        self.noise_water_HU = noise
        
        return mean_CT_number, noise

    def get_peripheral_locations(self, water_reference, from_edge):
        """
        determine the four ROIs for homogeneity at the peripheral zone
        locations are returned anticolockwise from degree of 0 (on the positve x axis)
        """
        xc, yc, r_water, r_phantom = self.get_phantom_center()
        ROI_r, _ = self.get_ROI_sizes(water_reference)

        r_from_ctr = r_water - (10./self.dataset.PixelSpacing[0])
        if from_edge:
            r_from_ctr -= ROI_r

        locs = [(xc + r_from_ctr, yc),
                (xc, yc + r_from_ctr),
                (xc - r_from_ctr, yc),
                (xc, yc - r_from_ctr),
                ]
        return locs
        
    def homogeneity(self, water_reference=False, from_edge=True):
        """
        test the homogeneity of the water phantom
        """
        img = self.image_array
        xc, yc, r_water, r_phantom = self.get_phantom_center()
        center_water, _ = self.water_roi(water_reference)

        # determine the diameter of the ROIs on the peripheral
        ROI_r, _ = self.get_ROI_sizes(water_reference)
        locs = self.get_peripheral_locations(water_reference, from_edge)

        diffs = []
        for x, y in locs:
            avg,std = avg_CT_number(img, (x,y), ROI_r)
            diffs.append(abs(avg - center_water))

        if DEBUG:
            print diffs
            timg = img.copy()
            h, w = timg.shape
            for x, y in locs:
                yg, xg = scipy.mgrid[:h, :w]
                mask = scipy.hypot(yg - y, xg - x) < ROI_r
                timg[scipy.where(mask)] = img.min()
            pylab.imshow(timg, cmap=pylab.cm.gray, interpolation='nearest')
            pylab.show()
            
        return max(diffs)
        
    
    def grid_generation(self, box_size):
        """
        generate multiple ROIs inside the uniform area inside the water phantom
        """
        # get the center
        xc, yc, r, phan_r = self.get_phantom_center()

        # determine the number of grids
        # the number of grid on one direction
        buffer_size = 20 # length that off the boundary
        n = int((r-buffer_size)*sqrt(2)/2/box_size)*2

        # generate the indices of the boxes
        ys, xs = scipy.mgrid[-n/2:n/2,-n/2:n/2] * box_size
        ys += int(round(yc))
        xs += int(round(xc))

        if DEBUG:
            pylab.imshow(self.image_array, cmap=pylab.cm.gray, interpolation='nearest')
            for y in ys:
                pylab.plot(xs[0], y, 'r-', linewidth=1)
            for i in range(xs.shape[1]):
                pylab.plot(xs[:,i], ys[:,i], 'g-', linewidth=.5)
            pylab.plot(xc, yc, 'o')
            pylab.show()

        return xs, ys
        
        
    def calculate_lcd(self, box_size, show_hist=False):
        xs, ys = self.grid_generation(box_size)
        # get ROIs
        ROIs = []
        img = self.image_array
        for x, y in zip(xs.ravel(), ys.ravel()):
            roi = img[y:y+box_size, x:x+box_size]
            ROIs.append(roi)

        ses = [e.std() for e in ROIs]
        means = [e.mean() for e in ROIs]

        if DEBUG:
            #print scipy.mean(ses)
            #print means
            print "roi size = %s or %s (mm)"%(box_size, box_size*self.dataset.PixelSpacing[0])
            print "contrast @95CL = %s"%(scipy.std(means)*3.29), "n=%d"%len(means)
            print "mean = %s; std = %s; "%(scipy.mean(means), scipy.std(means))
            
            _ = pylab.hist(means, bins=50)
            pylab.show()
            # a tabulate output
            heading = ["ROI size", "Instance", "Mean", "SE Mean", "STD", "SE STD", "Contrast"]
            tb = PrettyTable(heading)
            row = [box_size,
                   self.dataset.InstanceNumber,
                   "%6.3f"%scipy.mean(means),
                   "%6.3f"%scipy.std(means),
                   "%6.3f"%scipy.mean(ses),
                   "%6.3f"%scipy.std(ses),
                   "%6.3f"%(scipy.std(means)*3.29)]
            tb.add_row(row)
            print (tb)
            
        a= scipy.std(means)*3.29
        return a
class DICOM:
    def __init__(self, pn, seq, im, studyID):
        self.pn = pn
        self.seq = seq
        self.im = im
        self.studyID = studyID
    def Read(self, displayImage = False):
        dcm_dir = dicom.read_dicomdir(os.path.join(self.pn, "DICOMDIR"))
        seqs = dcm_dir.DirectoryRecordSequence
        for seqInd in range(len(seqs)):
            if seqs[seqInd].DirectoryRecordType == 'STUDY' and int(seqs[seqInd].StudyID) == self.studyID:
                for i in range(seqInd, len(seqs)):
                    if seqs[i].DirectoryRecordType == 'SERIES' and int(seqs[i].SeriesNumber) == self.seq:
                        #print 'Found the Series'
                        for j in range(i, len(seqs)):
                            #print 'Examing#%d '%j, seqs[j].DirectoryRecordType
                            if seqs[j].DirectoryRecordType == 'IMAGE' and int(seqs[j].InstanceNumber) == self.im:
                                print ('Found the Image, Seq #%d' %j)
                                fname = os.path.join(self.pn, os.path.join(*seqs[j].ReferencedFileID))
                                return fname
if __name__ == '__main__':
    #pn = 'D:\\Research\\INET\\Du_Guosheng\\data\\validation_dataset\\hepingli_hospital\\4-19\\4-19\\BSoft'
    pn = '..\\BSoft'
    pn = "D:\pythonct\py_codenew\new\py_code_latest\py_code_190214_from_Wu\py_code514\old_fromnew\change2\Z"#'..\\A\\Z02'
    seq = 7
    im = 1
    studyID = 1

    #displayImage = True
    #dicomIns = DICOM(pn, seq, im, studyID)
    #fname = dicomIns.Read(True)
    fname = "dcmt\\Z01"#pn
    ds = dicom.read_file(fname)
    
    if 1:#for f in os.listdir(pn):
        #fname = os.path.join(pn, f)
        test = Water_Phantom(fname)
        av,noise = test.water_roi()
        homogeneity = test.homogeneity()
        sz1 = 3#mm
        sz = int(round(sz1/ds.PixelSpacing[0]))
        a = test.calculate_lcd(sz)
        print ("the CT value of water phantom  is : ",av),
        print ("the noise of water phantom is : %s %%"%(noise*100)),
        print ("the homogeneity of water phantom is :",homogeneity),
        print ("the lcd is:",a)
